// # 오늘의 알고리즘 👍

// ## 📝 1. 크기가 작은 부분문자열

// ---

// 숫자로 이루어진 문자열 t와 p가 주어질 때, t에서 p와 길이가 같은 부분문자열 중에서, 이 부분문자열이 나타내는 수가 p가 나타내는 수보다 작거나 같은 것이 나오는 횟수를 return하는 함수 solution을 완성하세요.

// - 예를 들어, t="3141592"이고 p="271" 인 경우, t의 길이가 3인 부분 문자열은 314, 141, 415, 159, 592입니다.
// - 이 문자열이 나타내는 수 중 271보다 작거나 같은 수는 141, 159 2개 입니다.

// ### ▷ 입출력 예

// ```jsx
// solution("3141592", "271") // 2
// solution("500220839878", "7") // 8
// solution("10203", "15") // 3
// ```

// ### ▷ 내 풀이

// ```jsx
// function solution(t, p) {
//   let count = 0;
//   for(let i = 0; i < t.length - p.length + 1; i++) {
//     if(Number(t.slice(i, i + p.length)) <= Number(p))
//       count++
//   }
//   return count
// }
// ```

// ### ▷ 접근 방식

// `t`라는 변수에 들어온 값을 i번째부터 `p`의 길이값까지 잘라준 후에 비교를 해줘서 작거나 같은 수가 있으면 더해주는 식으로 문제를 풀었습니다.

// ## 📝 2. 크기가 작은 부분문자열

// ---

// 문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 ["sun", "bed", "car"]이고 n이 1이면 각 단어의 인덱스 1의 문자 "u", "e", "a"로 strings를 정렬합니다.

// - 제한 조건
//   - strings는 길이 1 이상, 50이하인 배열입니다.
//   - strings의 원소는 소문자 알파벳으로 이루어져 있습니다.
//   - strings의 원소는 길이 1 이상, 100이하인 문자열입니다.
//   - 모든 strings의 원소의 길이는 n보다 큽니다.
//   - 인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다.

// ### ▷ 입출력 예

// ```jsx
// solution(["sun", "bed", "car"], 1) // ["car", "bed", "sun"]
// solution(["abce", "abcd", "cdx"], 2) // ["abcd", "abce", "cdx"]
// ```

// ### ▷ 내 풀이

// ```jsx
// function solution(strings, n) {
//   strings.sort((a, b) => {
//     if (a[n] < b[n]) {
//       // 순서 유지 (a, b)
//       return -1;
//     } else if (a[n] > b[n]) {
//       // 순서 변경 (b, a)
//       return 1;
//     } else if (a < b) {
//       // 순서 유지 (a, b)
//       return -1;
//     } else if (a > b) {
//       // 순서 변경 (b, a)
//       return 1;
//     }
//     // 서로 변경 x 다른 요소 정렬
//     return 0;
//   })
//   return strings
// }
// ```

// ### ▷ 접근 방식

// `sort()` 매서드를 사용하여 n번째 인덱스값을 비교해서 정렬하고, 같은 문자열이 여럿 일 경우에는 사전순으로 정렬했습니다.

// ---
// >
// 출처: [프로그래머스](https://programmers.co.kr/)
// >
